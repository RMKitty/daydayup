[TOC]



## 1、I/O 主要分为两大类

### 1. 基于 **stdin** 与 **stdout** 文件读写

- 1) stdin => 标准输入文件
- 2) stdout => 标准输出文件

| NO | 函数名称  | 功能描述                   |
| ---- | --------- | -------------------------- |
| 2    | printf() | 将字节流写入文件 |
| 3    | scanf()  | 从文件读取字节流 |
| 4    | putc()   | 将一个字符写入文件 |
| 5    | getc()   | 从文件读取一个字符 |
| 6    | gets()   | 从文件读取一个字符串 |

### 2. 基于 **自己打开的文件** 读写

> 函数名就基本以 `f`（file）开头.

| NO | 函数名称  | 功能描述                   |
| ---- | --------- | -------------------------- |
| 1    | fopen()   | 打开新的或现有的文件 |
| 2    | fprintf() | 将字节流写入文件 |
| 3    | fscanf()  | 从文件读取字节流 |
| 4    | fputc()   | 将一个字符写入文件 |
| 5    | fgetc()   | 从文件读取一个字符 |
| 6    | fclose()  | 关闭文件 |
| 7    | fseek()   | 将文件指针设置为给定位置   |
| 8    | fputw()   | 将一个整数写入到文件       |
| 9    | fgetw()   | 从文件读取一个整数         |
| 10   | ftell()   | 返回当前文件指针的位置     |
| 11   | rewind()  | 将文件指针设置为文件的开头 |




## 2、每个进程默认打开三个文件

### 1. 全局变量定义

```c
#include <stdio.h>

extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
```

### 2. linux 中对应的 fd 宏定义

```c
#include <unistd.h>

#define	 STDIN_FILENO	0	/* standard input file descriptor */
#define	STDOUT_FILENO	1	/* standard output file descriptor */
#define	STDERR_FILENO	2	/* standard error file descriptor */
```


```
1：/dev/stdin, fd   == 0(STDIN_FILENO)
2：/dev/stdout, fd  == 1(STDOUT_FILENO)
3：/dev/stderr, fd  == 2(STDERR_FILENO)
```



## 3、基于 stdin、stdout 的文件读写

### 1. 主要的函数

```c
1. getchar()、putchar()
2. gets()、puts()
3. scanf()、printf()
4. fgets()、fputs() 
```

### 2. getchar() 与 putchar(): 1次读写 `1个字节`

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, const char * argv[]) 
{
  int c;

  printf( "请输入一个字符 :");
  c = getchar( );

  printf( "输入的字符: ");
  putchar( c );
  printf( "\n");
}
```

```
->  gcc main.c
->  ./a.out
请输入一个字符 :A
输入的字符: A
```

每次都是读写`1个字符`，不存在什么`缓存`的概念。

### 2. gets() 与 puts(): 1次读写 `1行（读取到\0字符结束）`

#### 1. 正常情况

> 运行时会提示：warning: this program uses gets(), which is unsafe.

```c
#include <stdio.h>

int main() 
{
  char str[10];

  printf( "Enter a value :");
  gets( str );

  printf( "You entered: \n");
  puts( str );
}
```

```
➜  main gcc main.c
➜  main ./a.out
warning: this program uses gets(), which is unsafe.
Enter a value :10
You entered:
10
➜  main
```

#### 2. 崩溃情况

如果输入的数据**超出**`char str[10];`10个字节长度，程序直接崩溃

```
➜  main ./a.out
warning: this program uses gets(), which is unsafe.
Enter a value :11111111111111
You entered:
11111111111111
[1]    3400 abort      ./a.out
➜  main
```

程序崩溃。

### 3. scanf() 与 printf(): 1次读写 `1行（读取到\0字符结束）`

#### 1. 正常情况

```c
#include <stdio.h>
#include <stdlib.h>


int main() 
{
  char name[10] = {0};
  
  //1. 从终端读取到内存
  scanf("%s", name);

  //2. 将内存中数据输出到终端
  printf("name = %s\n", name);
}
```

```
->  ./a.out
hello
name = hello
```

#### 2. 崩溃情况

同样输入的数据**超出**`char str[10];`10个字节长度，程序直接崩溃

```
->  ./a.out
123456789101
name = 123456789101
Abort trap: 6
```

### 4. fgets(): 从文件读取 `指定` 字节数【避免崩溃】

```c
#include <stdio.h>
#include <stdlib.h>


int main(int argc, const char * argv[]) 
{
  char name[10] = {0};
  
  //1.
  fgets(name, 10, stdin);

  //2.
  printf("name = %s\n", name);
}
```

```
->  gcc main.c
->  ./a.out
123456789101112
name = 123456789
```

输入超过了10个字符，但是没崩溃，只读取了`9`个字符，默认最后一个结束字符。




## 4、stdout 文件的缓冲区

### 1. printf() 缓冲区测试

```c
#include <stdio.h>
#include <stdlib.h>


int main(int argc, const char * argv[]) 
{
  //1. 带有 '\n' 字符
  printf("111111111\n");

  //2. 不带 '\n' 字符
  printf("222222222");

  //3. 死循环卡住进程，不让进程退出
  while(1){}
}
```

![printf缓冲区测试](printf缓冲区测试.gif)

- 1、**没有** 看到输出 **222222222**
- 2、然后就卡在 **while(1){}** 不再往下执行

原因：

- 1、因为`stdout`文件的缓冲区没有被刷新
- 2、当缓冲区 **没有满** 时，如果不手动刷新缓存，则不会将`缓存`中的数据写入到`文件`
- 3、也就无法看到屏幕上输出`2222222`

### 2. 手动刷新stdout的缓冲区，同步写入到stdout文件

尝试向`stdout`文件的缓冲区，写入大量的数据，让他自己被迫执行刷新缓冲区写入文件

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, const char * argv[])
{
  //1. 带有 \n
  printf("111111111\n");

  //2. 不带有 \n
  printf("222222222");

  //3. 强制刷新【stdout】文件的【缓冲区】，输出到屏幕
  fflush(stdout);

  //4. 死循环卡住进程
  while(1){}
}
```

![printf缓冲区测试2](printf缓冲区测试2.gif)

这次是输出完 **222222222**，然后再卡在 **while(1){}** 代码处。

### 3. stdout缓冲区满时，会触发刷新缓冲区，将内存数据写入到磁盘文件

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, const char * argv[])
{
  //1. 带有 \n
  printf("111111111\n");

  //2. 不带有 \n
  printf("222222222");

  //3. 不断的向缓冲区写入数据，等待缓冲区爆满
  int i;
  for (i = 0; i < 100; i++)
    printf("%c", 'A');

  //4. 死循环卡住进程
  while(1){}
}
```

![printf缓冲区测试3](printf缓冲区测试3.gif)

### 4. fclose() 关闭文件, 也会触发刷新缓冲区

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, const char * argv[])
{
  //1. 本地自己的文件
  FILE* pFile = fopen("./file.txt", "wb+");

  //2. 带有 \n
  fprintf(pFile, "111111111\n");

  //3. 不带有 \n
  fprintf(pFile, "222222222");

  //4. 关闭文件达到刷新缓冲区
   fclose(pFile);

  //5. 死循环卡住进程
  while(1){}
}
```

![printf缓冲区测试4](printf缓冲区测试4.gif)

- 在创建 **file.txt** 文件中可以看到没有使用 **\n** 
- 但是输出的 **22222222** 也写入到了文件



## 5、struct `FILE` 

- 1、FILE 并不是一个指向 `目标文件` 的指针变量
- 2、而是一个用来在对文件进行读写的过程中的一个 `辅助变量`
- 3、不能直接操作 `FILE` 实例
- 4、只能通过 `库函数` 来操作 `FILE` 实例

FILE的结构体精简如下:

```c
typedef struct { 
  int  _fd;   		  /* 1. 文件代号*/ 
  int  _cleft;      /* 2. 文件缓冲区所剩字节数*/ 
  int  _mode;    		/* 3. 文件使用模式*/ 
  char  *nextc;     /* 4. 下一个等待处理的字节地址， 即文件内部指针*/ 
  char  *buff;    	/* 5. 文件缓冲区首地址  */ 
}FILE;
```

所以说对于【标准C库 - 文件IO】来说的特点:

- (1) 必须通过`FILE*`地址来读写文件
- (2) `FILE*`并不是直接指向文件，而是通过内部的`_fd`标号来找到文件
- (3) 用于读取文件位置的指针，读取到末尾时，必须要恢复到最前面才能读取到数据



## 6、文件读写权限

### 1. 文件读写权限修饰符分类

| 模式   | 描述                                       |
| ---- | ---------------------------------------- |
| r    | 以**只读**方式打开文件。文件的指针将会放在文件的开头。这是默认模式。     |
| rb   | 以**二进制**格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 |
| r+   | 打开一个文件用于**读写**。文件指针将会放在文件的开头。            |
| rb+  | 以**二进制**格式打开一个文件用于**读写**。文件指针将会放在文件的开头。  |
| w    | 打开一个文件只用于**写入**。如果该文件已存在则将其**覆盖**。如果该文件**不存在**，则**创建新文件**。 |
| wb   | 以**二进制**格式打开一个文件只用于**写入**。如果该文件已存在则将其**覆盖**。如果该文件**不存在**，则**创建新文件**。 |
| w+   | 打开一个文件用于**读写**。如果该文件已存在则将其**覆盖**。如果该文件**不存在，创建新文件**。 |
| wb+  | 以**二进制**格式打开一个文件用于**读写**。如果该文件已存在则将其**覆盖**。如果该文件**不存在，创建新文件**。 |
| a    | 打开一个文件用于**追加**。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| ab   | 以**二进制**格式打开一个文件用于**追加**。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| a+   | 打开一个文件用于**读写**。如果该文件**已存在**，文件指针将会放在文件的**结尾**。文件打开时会是追加模式。如果该**文件不存在，创建新文件**用于读写。 |
| ab+  | 以**二进制**格式打开一个文件用于**追加**。如果该文件已存在，文件指针将会放在文件的结尾。如果该**文件不存在，创建新文件**用于读写。 |

### 2. 文件修饰符的表格总结形式

| 权限    | r    | r+   | w    | w+   | a（追加） | a+   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| 读     | Y    | Y    |      | Y    |      | Y    |
| 写     |      | Y    | Y    | Y    | Y    | Y    |
| 创建    |      |      | Y    | Y    | Y    | Y    |
| 覆盖    |      |      | Y    | Y    |      |      |
| 指针在开始 | Y    | Y    | Y    | Y    |      |      |
| 指针在结尾 |      |      |      |      | Y    | Y    |

### 3. 文件打开形式：【文本】与【二进制】

- 1）根据 **每一个字符** 对应的的 **ascii码值** 的进行存储
- 2）缺点：**体积大、平台差一些**
- 3）优点：比较容易看懂文件的数据内容

### 4. 文件打开形式：【二进制】

- 1）直接将**整个数据的二进制码**存储
- 2）优点：**体积小、可移植性高**
- 3）缺点：数据内容根本看不懂

### 5. `加b` 与 `不加b` 的区别

#### 1. 不加b => `文本文件` 读写文件

```c
FILE *file = fopen("1.txt", "w");
```

#### 2. 加b => `二进制` 读写文件


```c
FILE *file = fopen("1.txt", "wb");
```

### 6. 打开文件时, 加上 `b` 

- 1、**Linux/Unix** 中的文本文件，都是以 `\n` 为【换行符】
- 2、 **Windows** 中的文本文件，则是以 `\r\n` 为【换行符】
- 3、**linux 文件** 在 **windows 系统** 下在读写时，就需要将 `\n` 替换 `\r\n`，否则会出现 `乱码`
  - 3.1) **读取**文件时，替换文本中的`\r\n ==> \n`
  - 3.2) **写入**文件时，替换文本中的`\n ==> \r\n`

解决：不管 windows 还是 linux/unix ,【统一使用 `b` 二进制】进行读写，即可保证数据的【跨平台】性。

### 7. b 与 b+

#### 1. 读取

- 1）不需要写 => **rb**
- 2）同时需要**写** => **rb+**

#### 2. 写入

- 1) 不需要**读** => **wb**
- 2) 同时需要读 => **wb+**


## 7、fgetc()、fputc() 单个字符读写

### 1. 函数API

- 1、返回值为 `int`
- 2、当返回值为 `EOF` 时，表示文件已经读取完毕

```c
int
fgetc(FILE *stream);

int
fputc(int c, FILE *stream);
```

### 2. 代码示例

```c
#include <stdio.h>

int main(int argc, const char * argv[])
{ 
  char ch;
  
  // 依次读取每一个字节
  while ((ch = fgetc(stdin)) != EOF) 
  {
    printf("%c ", ch);
  }
}
```

当读取到 `EOF` 时，表示文件已经读取完毕。



## 8、fgets()、fputs() 行读写

### 1. fgets() | fputs()

- 1、返回值为 `char *`
- 2、当返回值为 `NULL` 时，表示文件已经读取完毕

```c
char *
fgets(char * restrict str, int size, FILE * restrict stream);

int
fputs(const char *restrict s, FILE *restrict stream);
```

### 2. 读取 stdin 标准输入

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main()
{ 
  //1. 内存缓冲区
  int buffSize = 1024;
  char buff[buffSize];
  
  //2. 一行一行读取标准输入文件的数据
  while (fgets(buff, buffSize, stdin) != NULL) 
    fputs(buff, stdout);
}
```

运行结果

<img src="./c标准_io_01.gif" alt="" title="" width="700"/>

### 3. 读取 fopen() 打开的文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, const char * argv[])
{ 
  //1.
  FILE * pFile = fopen ("./file.txt" , "r+");
  
  //2. 设定最大读取的字符串个数
  int buffSize = 1024;
  char buff[buffSize];
  
  //3.
  if (pFile == NULL) {
    perror ("Error opening file");
    return 1;
  }
  
  //4. 不断的从 ./file.txt 行读取
  while (fgets(buff, buffSize, pFile) != NULL) 
  {
    puts(buff);//输出字符串
  }


  //5. 
  fclose (pFile);
}
```

### 4. fputs() + fgets() 先写后读

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, const char * argv[])
{ 
  //1.
  FILE * pFile = fopen("./file.txt" , "w+");
  
  //2. 设定最大读取的字符串个数
  int buffSize = 1024;
  char buff[buffSize];
  
  //3.
  if (pFile == NULL) {
    perror ("Error opening file");
    return 1;
  }

  //4. 写入数据
  fputs("我是写入文件的内容", pFile);

  //5. 刷新缓冲区
  fflush(pFile);
  close(fileno(pFile));

  //6. 以读写方式【重新】打开文件
  // 因为之前的文件指针，已经指向文件的【末尾】，
  // 无法读取出文件内容
  pFile = fopen("./file.txt" , "r+");

  //7.
  while (fgets(buff, buffSize, pFile) != NULL) 
  {
    puts(buff);//输出字符串
  }

  //8. 
  fclose (pFile);
}
```

```
->   rm file.txt
->   gcc fgets使用.c
->   ./a.out
我是写入文件的内容
->   cat file.txt
我是写入文件的内容
```

### 5. 解析配置文件

```c
// 去除字符串中的所有空格字符
void trim(char *str)
{
  char* p = str;
  for(; *str != '\0' ; ++str)
  {
    if (' ' != *str)
    {
      *p = *str;
      p++;
    }
  }
  *p = '\0';
}

// 打开配置文件，读取出 key=value 后面的 value
void parse()
{
  char buf[1024] = {0};
  char* p;
  FILE* fd = fopen("./student.txt", "r");
  for (; NULL != fgets(buf, 1024, fd); )
  {
    buf[strlen(buf) - 1] = '\0';
    trim(buf);
    p = buf;
    for(;*p != '=';)
      p++;
    printf("%s\n", p);
  }
}
```



## 9、printf()、scanf() 基于stdin

```c
#include <stdio.h>

int
printf(
  const char * restrict format, ...
);

int
scanf(
  const char *restrict format, ...
);
```

```c
#define _GNU_SOURCE
#include <stdio.h>
int main()
{
  char name[64];
  int age;
  printf("请输入：姓名 年龄: ");
  scanf("%s %d", name, &age);
  printf("name = %s, age = %d\n", name, age);
}
```



## 10、fprintf()、fscanf() 基于 `FILE*` 读写

```c
#include <stdio.h>

int
fprintf(
  FILE * restrict stream, 
  const char * restrict format, ...
);

int
fscanf(
  FILE *restrict stream, 
  const char *restrict format, ...
);
```

```c
#define _GNU_SOURCE
#include <stdio.h>
int main()
{
  char name[64];
  int age;
  FILE* f;
    
  // 打开文件
  f = fopen("./txt", "w+");
    
  // 写入 ./txt 文件，文件指针移动到末尾
  fprintf(f, "%s %d\n", "xiong", 19);

  // 移动文件指针到文件起始位置
  rewind(f);

  // 按照指定的格式化，读取文件内容到变量关联的内存中
  fscanf(f, "%s %d", name, &age); // 默认以空格字符作为分解符读取

  // 将读取到的变量的内存数据，写入到stdout输出到屏幕
  printf("name = %s, age = %d\n", name, age);
}
```

```
->  gcc main.c
->  ./a.out
name = xiong, age = 19
->
->  cat txt
xiong 19
->
```



## 11、sprintf()、snprintf()、sscanf() 基于 `内存块` 读写

### 1. 函数声明

```c
#include <stdio.h>

int
sprintf(
  char * restrict str, 
  const char * restrict format, ...
);

int
snprintf(
  char * restrict str, 
  size_t size, 
  const char * restrict format, ...
);

int
sscanf(
  const char *restrict s, 
  const char *restrict format, ...
);
```

### 2. sscanf() 必须提前【分配内存】


```c
#define _GNU_SOURCE
#include <stdio.h>
int main()
{
  // 1. 内存输入数据源
  char buf[] = "name=xiong age=19";

  // 2. 从buf内存块中读取输入数据
#if 1
  char* name; // error: 导致崩溃，因为并没有分配指向的内存空间，仅仅只是一个指针变量
#else
  char name[64]; // ok: 必须是分配存储的内存
#endif
  int age;

  // 3.
  sscanf(buf, "name=%s age=%d", name, &age);

  // 4.
  printf("name = %s, age = %d\n", name, age);
}
```

```
->  gcc main.c
->  ./a.out
[1]    15353 segmentation fault  ./a.out
->
```

### 3. sprintf() 变量格式化组装到内存块 

```c
#define _GNU_SOURCE
#include <stdio.h>
int main()
{
  // 1. 内存输入数据源
  char buf[] = "name=xiong age=19";

  // 2. 从buf内存块中读取输入数据
  char name[64]; // 注意：必须分配一块内存，不能是指针变量
  int age;
  sscanf(buf, "name=%s age=%d", name, &age);
  printf("name = %s, age = %d\n", name, age);

  // 3.
  char buf2[1024] = {0};
  sprintf(buf2, "[name]=%s, [age]=%d", name, age);
  printf("buf2 = %s\n", buf2);
}
```

```
➜  main gcc main.c
➜  main ./a.out
name = xiong, age = 19
buf2 = [name]=xiong, [age]=19
➜  main
```

### 4. sscanf() 解析key=value字符串

```c
#define _GNU_SOURCE
#include <stdio.h>

/** 去掉字符串中所有的空格 */
void trim(char *str)
{
  // p
  char* p = str;

  // str从头到尾遍历字符串str
  for(; *str != '\0' ; ++str)
  {
    if (' ' != *str) // 如果str指向的字符不是空格字符
    {
      *p = *str; // 将str指向的字符拷贝到p指向的位置
      p++; // p往后移动一个位置
    }
  }

  // 最后在p指向的【空】位置填充结束符\0
  *p = '\0';
}

int main()
{
  // 1. 内存输入数据源
#if 0
  char buf1[] = "name=xiong"; // 正常情况，key=value 之间只能有一个空格字符
  char buf2[] = "age=19";
#else
  char buf1[] = "   name =xiong   "; // 非正常情况
  char buf2[] = "age   = 19";
#endif

  // 2. 处理buf中字符串的多余空格字符串
  printf("buf1[%s], buf2[%s]\n", buf1, buf2);
  trim(buf1);
  trim(buf2);
  printf("buf1[%s], buf2[%s]\n", buf1, buf2);

  // 3. 分配最终读取数据的存储内存
  char name[64]; // 注意：必须分配一块内存，不能是指针变量
  int age;

  // 4. 从buf内存块中读取输入数据，读取到上面分配的内存中
  sscanf(buf1, "name=%s", name);
  sscanf(buf2, "age=%d", &age);
  printf("name = %s, age = %d\n", name, age);
}
```

```
➜  main make
gcc main.c
./a.out
buf1[   name =xiong   ], buf2[age   = 19]
buf1[name=xiong], buf2[age=19]
name = xiong, age = 19
➜  main
```

### 5. sscanf() 解析key=value配置文件 

```c
// 去除字符串中的所有空格字符
void trim(char *str)
{
  char* p = str;
  for(; *str != '\0' ; ++str)
  {
    if (' ' != *str)
    {
      *p = *str;
      p++;
    }
  }
  *p = '\0';
}

// 打开配置文件，读取出 key=value 后面的 value
void parse()
{
  char buf[1024] = {0};
  char name[64]; // 注意：必须分配一块内存，不能是指针变量
  int age;
  FILE* fd = fopen("./student.txt", "r");
  for (; NULL != fgets(buf, 1024, fd); )
  {
    buf[strlen(buf) - 1] = '\0';
    trim(buf);
    sscanf(buf, "name=%s age=%d", name, &age);
    printf("name = %s, age = %d\n", name, age);
  }
}
```

### 6. sscanf() 正则式

#### 0. 常用正则式对照表

![](20161218131342960.png)

#### 1. 取指定长度的字符串 

```c
#include<stdio.h>
#include<string.h>

int main()
{
  char buf[512] = {0};
  sscanf("123456 ", "%4s", buf);
  printf("%s\n", buf);
}
```

```
➜  main make
gcc main.c
./a.out
1234
➜  main
```

#### 2. 取到指定字符为止的字符串

```c
#include<stdio.h>
#include<string.h>

int main()
{
  char buf[512] = {0};

  sscanf("123456 abcdedf", "%[^ ]", buf);//取到以空格字符结束
  printf("%s\n", buf);

  sscanf("123456 abcdedf", "%[^e]", buf);//取到以e字符结束
  printf("%s\n", buf);

  sscanf("123456 abcdedf", "%[^6]", buf);//取到以6字符结束
  printf("%s\n", buf);

  sscanf("123456abcdedfBCDEF", "%[^A-Z]", buf);//取遇到大写字母为止的字符串
  printf("%s\n", buf);
}
```

```
➜  main make
gcc main.c
./a.out
123456
123456 abcd
12345
123456abcdedf
➜  main
```

#### 3. 取仅包含指定字符集的字符串

```c
#include<stdio.h>
#include<string.h>

int main()
{
  char buf[512] = {0};

  sscanf("123456abcdedfBCDEF", "%[1-9a-z]", buf);
  printf("%s\n", buf);

  sscanf("123 456 abcdedf BCDEF", "%[1-9a-z]", buf);
  printf("%s\n", buf);
}
```

```
➜  main make
gcc main.c
./a.out
123456abcdedf
123
➜  main
```

遇到空格会结束。

#### 4. 以空格字符切割读取字符串

```c
char method[16];      // get、post
char path[256];       // /hello.c
char protocol[16];    // HTTP/1.1

char* line = "GET /hello.c HTTP/1.1";
sscanf(line, "%[^ ] %[^ ] %[^ ]", method, path, protocol);	
printf("method=%s, path=%s, protocol=%s\n", method, path, protocol);
```

#### 5. 截取"iios/12DDWDFF@122"中，获取 / 和 @ 之间的字符串

```c
#include<stdio.h>
#include<string.h>

int main()
{
  char buf[512] = {0};

  sscanf("iios/12DDWDFF@122", "%[^/]", buf);
  printf("%s\n", buf);

  sscanf("iios/12DDWDFF@122", "%[^@]", buf);
  printf("%s\n", buf);

  // 先将 "iios/"过滤掉，再从剩下的"12DDWDFF@122"中匹配到12DDWDFF
  sscanf("iios/12DDWDFF@122", "%*[^/]/%[^@]", buf);
  printf("%s\n", buf);
}
```

```
➜  main make
gcc main.c
./a.out
iios
iios/12DDWDFF
12DDWDFF
➜  main
```

#### 6. "hello, world" 仅保留 world

```c
#include<stdio.h>
#include<string.h>

int main()
{
  char buf[512] = {0};

  sscanf("hello, world", "%s", buf); // %s 遇到空格字符结束
  printf("%s\n", buf);

  sscanf("hello, world", "%*s%s", buf); // %*s 包含空格字符切割
  printf("%s\n", buf);
}
```

```
➜  main make
gcc main.c
./a.out
hello,
world
➜  main
```

#### 7. 分隔字符串"2006:03:18"

```c
#include<stdio.h>
#include<string.h>

int main()
{
  char buf[512] = {0};

  int a, b, c;
  sscanf("2006:03:18", "%d:%d:%d", &a, &b, &c);
  printf("a = %d, b = %d, c = %d\n", a, b, c);
}
```

```
➜  main make
gcc main.c
./a.out
a = 2006, b = 3, c = 18
➜  main
```

#### 8. 分隔字符串"2006:03:18 - 2006:04:18"

```c
#include<stdio.h>
#include<string.h>

int main()
{
  char sztime1[16] = "";
  char sztime2[16] = "";

#if 1
  sscanf("2006:03:18 - 2006:04:18", "%s - %s", sztime1, sztime2);
#else
  sscanf("2006:03:18-2006:04:18", "%[0-9,:] - %[0-9,:]", sztime1, sztime2);
#endif

  printf("%s\n", sztime1);
  printf("%s\n", sztime2);
}
```

```
➜  main make
gcc main.c
./a.out
2006:03:18
2006:04:18
➜  main
```



## 12、fopen()、fgets()/fputs()、sscanf()

- 读取本地**student.txt**文件
- 解析生成Student结构体实例数组
- Student结构体实例数组的冒泡排序
- 将排序后的Student结构体实例数组写入到**student2.txt**文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct _tag_Student { 
  char name[24]; 
  int age; 
}Student; 

typedef struct _listNode {
  Student *stu; 
  struct _listNode *next; 
}ListNode;
ListNode head = {NULL, NULL};

void callback(char* name, int age)
{
  Student* s = (Student*)malloc(sizeof(Student));
  strcpy(s->name, name);
  s->age = age;

  ListNode* l = (ListNode*)malloc(sizeof(ListNode));
  l->stu = s;
  l->next = head.next;
  head.next = l;
}

int getStudentInfo(void (*funcp)(char* name, int age))
{
  FILE* fd;
  char buf[1024];
  char name[24];
  int age;
  fd = fopen("./student.txt", "r");
  if (NULL == fd) return -1;
  for (; NULL != fgets(buf, 1024, fd); )
  {
    buf[strlen(buf) - 1] = '\0';
    sscanf(buf, "name=%s age=%d\n", name, &age);
    funcp(name, age);
  }
  fclose(fd);
  return 0;
}

void maopao(Student** arr, int len, int (*CMP)(Student*, Student*))
{
  int i,j, ret;
  int exchange;
  Student* t;
  exchange = 1; 
  for (i = 0; (i < len) && (1 == exchange); i++)
  {
    exchange = 0; 
    for (j = len-1; j > i; j--) 
    {
      ret = CMP(arr[j-1], arr[j]);
      if (ret > 0)
      {
        t = arr[j-1];
        arr[j-1] = arr[j];
        arr[j] = t;
        exchange = 1;
      }
    }
  }
}

int maopao_callback(Student*left, Student*right)
{
  return left->age > right->age;
}

void write_to_file(Student** stus, int len);
void sort()
{
  ListNode* t = head.next;
  int i, len = 0;
  Student** stus;
  for (; NULL != t ;)
  {
    ++len;
    t = t->next;
  }
  // printf("==> %d\n", len);
  stus = (Student**)malloc(sizeof(Student*) * len);
  t = head.next;
  for (; NULL != t ; i++)
  {
    stus[i] = t->stu;
    t = t->next;
  }
  maopao(stus, len, maopao_callback);
  write_to_file(stus, len);
  free(stus);
}

void write_to_file(Student** stus, int len)
{
  int i;
  FILE* fd;
  char buf[1024];
  fd = fopen("./student2.txt", "w");
  for (i=0; i<len; i++)
  {
    Student* s = (Student*)stus[i];
    memset(buf, 0, 1024);
    sprintf(buf, "name=%s age=%d\n", s->name, s->age);
    fputs(buf, fd);
  }
  fclose(fd);
}

int main()
{
  getStudentInfo(callback);
  sort();
}
```

查看本地的student.txt文件

```
->  cat student.txt
name=suyu age=20
name=haha age=23
name=lili age=22
name=xixi age=27
name=lucy age=18
name=lala age=33%                                                                                                             ->
```

编译链接运行如上main.c

```
->  gcc main.c
->  ./a.out
->
->  cat student2.txt
name=lala age=3
name=lucy age=18
name=suyu age=20
name=lili age=22
name=haha age=23
name=xixi age=27
->
```

student2.txt文件中的记录按照age从小到大排列。



## 13、fwrite() 与 fread() 读写 `二进制` 流

### 1. fwrite() 将内存数据写入到文件

#### 1. double[] => 文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

enum { SIZE = 5 };

int main(int argc, const char * argv[])
{ 
  //1. 
  double buff[SIZE] = {1, 2, 3, 4, 5};

  //2. 
  FILE *pFile = fopen("file.txt", "wb+");

  //3. 
  int ret = fwrite(
    buff, 
    sizeof buff[0], // 1次写入的大小
    SIZE, // 写入的总次数
    pFile
  );

  //4.
  printf("写入长度 = %d\n", ret);

  //5.
  fclose(pFile);
}
```

运行输出

```
->   rm file.txt
->   gcc write_int.c
->   ./a.out
->   cat file.txt
�?@@@

```

#### 2. struct person[] => 文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

typedef struct person {
    int age;
    char name[30];
}person;

int main(int argc, const char * argv[])
{ 
  //1.
    person per[3];
    per[0].age=20;strcpy(per[0].name,"li");
    per[1].age=18;strcpy(per[1].name,"wang");
    per[2].age=21;strcpy(per[2].name,"zhang");

    //2.
    FILE* pFile = fopen("./file.txt", "wb+");

    //3. 依次将 per[i] 写入一次，写入到文件中
    for(int i = 0;i < 3; i++)
    {
        //3.1
        int ret = fwrite(
                            &per[i],  // 要写入的内存起始地址
                            sizeof(person),  // 内存长度
                            1,  // 写入次数
                            pFile // 文件指针
                        );

        //3.2
        if(ret <= 0) 
        {
            perror("fwrite error: ");
        }
    }

  return 0;
}	
```

运行输出

```
->   gcc write_struct.c
->   ./a.out
->   cat file.txt
liv��j�੒P�੒P�wangP-H��j���P�zhang

```

#### 3. 不要将指针类型的成员变量值写入到文件 

```c
struct person
{
  int pid;
  char* name;//指向的是一个内存地址
};
```

- name指向的内存地址随时可能被**释放废弃**
- 所以不能将**内存地址**写入到文件
- 应该是将指针变量指向的**内存地址中**的**数据值**写入到文件中
- 再读取文件时，**重新分配一块内存**，来存储读取出来的**数据值**

### 2. fread() 从磁盘文件读入到内存

#### 1. 读取文件字符

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
  char inbuf[1024];
  int ret = 0, read_len = 0;
  FILE *in;

  // 1.
  parser = ucl_parser_new(0);

  // 2. 读取配置文件
  in = fopen("./test.conf", "r+");
  for (; !feof(in) ;)
  {
    read_len += fread (
      inbuf + read_len, 
      1, 
      sizeof (inbuf) - read_len, 
      in
    );
    printf("inbuf = %s\n", inbuf);
  }

  // 3.
  fclose (in);
}
```

```
➜  main gcc main.c
➜  main ./a.out
inbuf = param = value;
section {
  param = value;
  param1 = value1;
  flag = true;
  number = 10k;
  time = 0.2s;
  string = "something";
  subsection {
    host = {
      host = "hostname";
      port = 900;
    }
    host = {
      host = "hostname";
      port = 901;
    }
  }
}
➜  main
```

#### 1. 文件 => double[]

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, const char * argv[])
{ 
    //1.
    FILE* pFile = NULL;
    double buffer[10] = {0};

    //2.
    if((pFile = fopen("./file.txt", "rb+")) == NULL)
    {
      printf("cant open the file");
      exit(0);
    }

    //3.
    int ret = fread(
      buffer, //将文件数据读入到缓冲区
      sizeof(buffer[0]), //每一个元素的大小
      5, //读取几次
      pFile//从哪个文件读取
    );

    //4. 之前写入了5个数据
    if(ret != 5)   
    {
      printf("file read error\n");
      exit(0);
    }

    //5.
    for(int i = 0;i < 10; i++) {
      printf("%f\n", buffer[i]);
    }

  return 0;
}	
```

运行输出

```
1.000000
2.000000
3.000000
4.000000
5.000000
0.000000
0.000000
0.000000
0.000000
0.000000
```

#### 2. 文件 => struct person[]

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

typedef struct person {
    int age;
    char name[30];
}person;

int main(int argc, const char * argv[])
{ 
    //1.
    FILE* pFile = NULL;
    person buffer[10] = {0};

    //2.
    pFile = fopen("./file.txt", "rb+");

    //3.
    int ret = fread(
                        buffer, //将文件数据读入到缓冲区的内存起始地址
                        sizeof(person), //每一个元素的大小
                        3, //读取几次
                        pFile//从哪个文件读取
                    );

    //4. 之前写入了3个数据
    if(ret != 3)   
    {
        printf("file read error\n");
        exit(0);
    }

    //5.
    for(int i = 0;i < 3; i++) {
        printf("age = %d, name = %s\n", buffer[i].age, buffer[i].name);
    }
    
  //6.
   fclose(pFile);
  
  return 0;
}	
```

运行输出

```
->   cat file.txt
livBzd��)�W��)�W�wang��H2zd�*�W�zhang
->   gcc fread_struct.c
->   ./a.out
age = 20, name = li
age = 18, name = wang
age = 21, name = zhang

```

### 3. `double[]`读写综合示例

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

enum { SIZE = 5 };

int main(int argc, const char * argv[])
{
  int i;
  double a[SIZE] = {1, 2, 3, 4, 5};
  double b[SIZE];

   FILE *pFile = fopen("./file.txt", "wb+");
      int ret = fwrite(
        a,
        sizeof a[0],
        SIZE,
        pFile
      );

  for (i = 0; i < SIZE; i++)
   {
    printf("%f ", a[i]);
  }
  printf("\n");
  fclose(pFile);

   pFile = fopen("./file.txt", "rb");
  fread(
    b,
    sizeof b[0],
    SIZE,
    pFile
  );

  for (i = 0; i < SIZE; i++)
   {
    printf("%f ", b[i]);
  }
  printf("\n");
      fclose(pFile);

  return 0;
}
```

### 4. `struct person[]`读写综合示例

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

typedef struct person {
    int age;
    char name[30];
}person;

int main(int argc, const char * argv[])
{
    //1.
    FILE* pFile = NULL;
    size_t ret;
    person buffer[10] = {0};
    person buffer2[10];
    
    //2.
    person per[3];
    per[0].age=20;strcpy(per[0].name,"li");
    per[1].age=18;strcpy(per[1].name,"wang");
    per[2].age=21;strcpy(per[2].name,"zhang");
    
    //3.
    pFile = fopen("./file.txt", "wb+");
    
    //4. 依次将 per[i] 写入一次，写入到文件中
    for(int i = 0;i < 3; i++)
    {
        //4.1
        ret = fwrite(
                         &per[i],
                         sizeof(person),
                         1,
                         pFile
                    );
        
        //4.2
        if(ret <= 0)
        {
            perror("fwrite error: ");
        }
    }
    
    //5.
    fclose(pFile);
    
    //6.
    pFile = fopen("./file.txt", "rb+");
    
    //7.
    ret = fread(
                    buffer2, //将文件数据读入到缓冲区
                    sizeof(person), //每一个元素的大小
                    3, //读取几次
                    pFile//从哪个文件读取
                );
    
    //8. 之前写入了3个数据
    if(ret != 3)
    {
        printf("file read error\n");
        exit(0);
    }
    else
    {
        printf("ret = %ld\n", ret);
    }
    
    //9.
    for(int i = 0;i < 3; i++)
    {
        printf("age = %d, name = %s\n", buffer2[i].age, buffer2[i].name);
    }
    
    //10.
    fclose(pFile);
    
    return 0;
}	
```



## 14、文件被多次同时打开写入时, 会产生 `覆盖` 问题

### 1. 每次打开文件使用 wb+

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

typedef struct person {
    int age;
    char name[30];
}person;

int main(int argc, const char * argv[])
{
    //1.
    size_t ret;
    FILE* pFiles[10];
    person pers1[10];
    FILE* pFile = NULL;
    person pers2[10];
    
    /**
     *  file.txt 同时打开10个指向
     */
    for (int i = 0; i < 10; ++i)
    {
        pFiles[i] = fopen("./file.txt", "wb+"); // 每次打开文件使用 wb+
        pers1[i].age = i + 1;
        sprintf(pers1[i].name, "%d", pers1[i].age);
      
        fwrite(&(pers1[i]), sizeof(person), 1, pFiles[i]);
    }
    
    /**
     * 3. 先关闭谁，就谁先刷新缓冲区，写入到文件
     *    并且是【覆盖】其他的文件写入的数据
     */
    fclose(pFiles[0]);
  fclose(pFiles[1]);
  fclose(pFiles[2]);
  fclose(pFiles[3]);
  fclose(pFiles[4]);
  fclose(pFiles[5]);
  fclose(pFiles[6]);
  fclose(pFiles[7]);
  fclose(pFiles[8]);
    fclose(pFiles[9]);//上面的9次写入都被此次覆盖
    
    printf("=========================\n");
    
    //4. 查看最终写入的数据
    pFile = fopen("./file.txt", "rb+");
    ret = fread(
                    pers2,
                    sizeof(person),
                    10,
                    pFile
                );
    
    for (int i = 0; i < 10; ++i)
      printf("age = %d, name = %s\n", pers2[i].age, pers2[i].name);

    fclose(pFile);
}
```

```
->  gcc printf.c
->  ./a.out
=========================
age = 10, name = 10
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
->
```

- 哪一个`FILE*`**最后执行**`close()`最后执行刷新缓冲区，就会将当前`FILE*`自己缓冲区的数据
- 并且是`覆盖式`写入到磁盘文件中，那么其他`FILE*`写入的数据将会被**覆盖掉**

### 2. 只有第一次打开文件使用 wb+

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

typedef struct person {
    int age;
    char name[30];
}person;

int main(int argc, const char * argv[])
{
    //1.
    size_t ret;
    FILE* pFiles[10];
    person pers1[10];
    FILE* pFile = NULL;
    person pers2[10];
    
    /**
     *  file.txt 同时打开10个指向
     */
    for (int i = 0; i < 10; ++i)
    {
        if (i == 0)
        {
            pFiles[i] = fopen("./file.txt", "wb+"); // 只有第一次次打开文件使用 wb+
        }
        else
        {
            pFiles[i] = fopen("./file.txt", "wb");
        }
        
        pers1[i].age = i + 1;
        sprintf(pers1[i].name, "%d", pers1[i].age);
      
        fwrite(&(pers1[i]), sizeof(person), 1, pFiles[i]);
    }
    
    /**
     * 3. 先关闭谁，就谁先刷新缓冲区，写入到文件
     *    并且是【覆盖】其他的文件写入的数据
     */
   fclose(pFiles[0]);
   fclose(pFiles[1]);
   fclose(pFiles[2]);
   fclose(pFiles[3]);
   fclose(pFiles[4]);
   fclose(pFiles[5]);
   fclose(pFiles[6]);
   fclose(pFiles[7]);
   fclose(pFiles[8]);
   fclose(pFiles[9]);
    
    printf("=========================\n");
    
    //4. 查看最终写入的数据
    pFile = fopen("./file.txt", "rb");
    ret = fread(
        pers2,
        sizeof(person),
        10,
        pFile
    );
    
    for (int i = 0; i < 10; ++i)
      printf("age = %d, name = %s\n", pers2[i].age, pers2[i].name);
    
    fclose(pFile);
}
```

```
->  gcc printf.c
->  ./a.out
=========================
age = 10, name = 10
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
age = 0, name =
->
```

和上面效果一样的。



## 15、大文件分成固定大小切割读取

### 1. 每次从文件A读取 `4k字节(4 * 1024 字节)` 数据，然后写入文件B

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, const char * argv[])
{ 
  //1.
  FILE* src_file = fopen("./file.avi", "rb");
  
  //2.
  if(src_file == NULL) 
  {
    printf("cant open the file");
    exit(0);
  }
    
  //3. 每次读取4*1024（4K）字节的数据到缓冲区
  unsigned int buffSize = 4 * 1024;
  unsigned char buff[buffSize];

  //4. 打开重新写入到的文件
  FILE* dst_file = fopen("./file_copy.avi", "wt+");

  //5. 依次按照4K大小切割读取文件
  for(; !feof(src_file) ;)
  {
    //5.1 将4k大小文件数据读入到buff中，并接收每次读取到的大小
    size_t len = fread(
      buff,     // 将数去读取到指定的缓冲区
      1,        // 每一次读取一个字节
      buffSize, // 每一次读取的次数
      src_file  // 从哪个文件读取数据
    );
    printf("读取长度 = %ld\n", len);

    //5.2 文件读取完毕
    if (len <= 0)
      break;
    
    //5.3 是否读取完毕
    if (len < buffSize) 
    {
      // <= 4K的最后一部分数据
      fwrite(
        buff, 
        len, // 写入剩下的长度
        1, 
        dst_file
      );
      //fflush(dst_file);
    } else {
      // >= 4K数据
      fwrite(
        buff, 
        buffSize, // 写入4K字节的长度
        1, 
        dst_file
      );
      //fflush(dst_file);
    }
  }

  //6.
  fclose(src_file);
  fclose(dst_file);
}
```

运行输出

```
->     ls -lHs file*
32320 -rwxr-xr-x  1 xiongzenghui  staff  16547328  9  7  2016 file.avi
->     gcc 大文件切割读写.c
->     ./a.out
.............
->     ls -lHs file*
32320 -rwxr-xr-x  1 xiongzenghui  staff  16547328  9  7  2016 file.avi
32320 -rw-r--r--  1 xiongzenghui  staff  16547328  7 25 11:26 file_copy.avi
```

### 2. 将读取和输出文件由命令行参数传入

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argv, char* argr[])
{
  //1.
  FILE *f1, *f2;
  char buff[BUFSIZ];

  //2.
  f1 = fopen(argr[1], "rb");//只读
  f2 = fopen(argr[2], "wb+");// 建立文件 + 清零文件

  //3.
  int len;
  while(!feof(f1))
  {
    //3.1
    len = fread(buff, sizeof(buff), 1, f1);

    //3.2
    if (len < 0)
    {
      fclose(f1);
      fclose(f2);
      return -1;
    }

    /**
     *  3.3
     *
     *  - (1) len < BUFSIZ, 只剩下一小部分数据需要写入
     *  - (2) len == BUFSIZ, 还有缓冲区大小的数据写入
     */
    if (len < BUFSIZ)
    {
      fwrite(buff, strlen(buff), 1, f2);
      //fflush(f2);
    }
    else
    {
      fwrite(buff, BUFSIZ, 1, f2);
      //fflush(f2);
    }
  }

  //4.
  fclose(f1);
  fclose(f2);
}
```

运行输出

```
xiongzenghui@ubuntu:~/share$ rm text2
xiongzenghui@ubuntu:~/share$ gcc test4.c
xiongzenghui@ubuntu:~/share$ cat text1
1111111111111111
2222222222222222
xiongzenghui@ubuntu:~/share$ ./a.out text1 text2
xiongzenghui@ubuntu:~/share$ cat text2
1111111111111111
2222222222222222
xiongzenghui@ubuntu:~/share$ cat test4.c
```



## 16、操作文件的 `位置指针`

### 1. fseek() 移动到指定位置

```c
int
fseek(
  FILE *stream, 
  long offset, 
  int whence
);
```

### 2. rewind() 恢复指向文件 `起始位置`

```c
void
rewind(FILE *stream);
```

### 3. 完整示例

<img src="./cyuyan_25.png" alt="" title="" width="750"/>

假设 `file.txt` 文件中存储了3个 `struct person` 的实例，那么通过`fseek()`移动输入光标进行读写

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

typedef struct person {
  int age;
  char name[30];
}person;

int main()
{ 
  //1.
  FILE* pFile = NULL;

  //2.
  if((pFile = fopen("./file.txt", "rb")) == NULL)
  {
    printf("cant open the file");
    exit(0);
  }

  //3.
  person per = {0};

  //4. 读取persons[1]
  {
    //4.1 向后移动1个person长度
    fseek(
      pFile, 
      1 * sizeof(struct person), 
      SEEK_SET
    );

    //4.2 读取persons[1]
    fread(
      &per,
      1,
      sizeof(struct  person),
      pFile
    );

    //4.3
    printf("age = %d, name = %s\n", per.age, per.name);
}

  //5. 读取persons[0]
  {
    //5.1 让输入光标回到起始位置
    rewind(pFile);

    //5.2
    fread(
      &per,
      1,
      sizeof(struct  person),
      pFile
    );

    //5.3
    printf("age = %d, name = %s\n", per.age, per.name);
  }

  //6. 让输入光标移动到末尾
  fseek(
    pFile, 
    0, 
    SEEK_END
  );

  //7.
  fclose(pFile);
}	
```

```
->   gcc write_struct.c
->   ./a.out
->   gcc fseek使用.c
->   ./a.out
age = 18, name = wang
age = 20, name = li
```

### 4. rewind(fp) 让文件指针指向文件的起始位置 

```c
#include<stdio.h>   

void main() 
{
  FILE *fp;
  char c;

  fp = fopen("file.txt", "r");
  while ((c = fgetc(fp)) != EOF) {
    printf("%c", c);
  }

  // moves the file pointer at beginning of the file  
  rewind(fp); 
  
  // 不用重新打开文件，直接从头读取内容
  while ((c = fgetc(fp)) != EOF) {
    printf("%c", c);
  }

  fclose(fp);

}
```

### 5. `fseek(f1, 0, SEEK_SET)` 也可以让文件指针移动到文件`起始`位置

下面代码第一次对文件读取完毕之后，继续使用这个`FILE*`重新读取到文件的完整数据.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argv, char* argr[])
{
  //1. 
  FILE *f1;
  char buff[BUFSIZ];

  //2. 
  f1 = fopen(argr[1], "rb+");
  
  //3. 读第一次
  printf("==============%d次读取文件===========>\n", 1);
  int len;
  while(!feof(f1))
  {
    len = fread(
      buff, /* 将数据读取到指定的缓冲区 */
      1, /* 【重点】每一次读取一个字节的长度 */
      sizeof(buff), /* 读取的次数 */
      f1 /* 从哪个文件读取 */
    );
    printf("读取到的长度 = %d\n", len);
  }

  //4. 读第二次
  printf("==============%d次读取文件===========>\n", 2);
  len = -1;
  memset(buff, 0, sizeof(buff));
  while(!feof(f1))
  {
    len = fread(buff, 1, sizeof(buff), f1);
    printf("读取到的长度 = %d\n", len);
  }
  printf("\n");

  //5. 读第三次
  printf("==============%d次读取文件===========>\n", 3);
  len = -1;
  memset(buff, 0, sizeof(buff));

  /**
   *  让 FILE* 指向的文件指针恢复到最开始的位置
   */
  fseek(f1, 0, SEEK_SET);

  // 再读取
  while(!feof(f1))
  {
    len = fread(buff, 1, sizeof(buff), f1);
    printf("读取到的长度 = %d\n", len);
  }
  printf("\n");  

  //6. 
  fclose(f1);
}
```

```
xiongzenghui@MacBook-Pro:~/Desktop$     gcc test.c
xiongzenghui@MacBook-Pro:~/Desktop$     ./a.out file.txt
==============1次读取文件===========>
读取到的长度 = 38
==============2次读取文件===========>

==============3次读取文件===========>
读取到的长度 = 38
```

### 6. ftell() 函数返回距离文件起始位置的字节数

```c
#include <stdio.h>  

void main() {
  FILE *fp;
  int length;

  fp = fopen("myfile.txt", "r");
  fseek(fp, 0, SEEK_END); // 移动到文件末尾
  length = ftell(fp); // 计算出距离，得到文件字节数
  fclose(fp);
  printf("Size of file: %d bytes", length);
}
```



## 17、其他文件操作

### 删除文件

```c
int unlink(const char *pathname);
```

### 创建临时文件

```c
char *tmpnam(char *s);
```

使用

```c
char file[1024] = "...../file.txt"
tmpnam(file);
```

创建的文件存储在`/tmp`下。



## 18、setbuf() 设置使用自己的内存缓冲区

### 1. setbuf()

```c
#include <stdio.h>

void
setbuf(
  FILE *restrict stream,
  char *restrict buf
);
```

### 2. 默认情况下 stdio 带有【用户缓冲区】

```c
#include <stdio.h>
int main()
{
  printf("Hello"); //没有使用\n，所以不会主动刷新缓冲区
  while(1);
}
```

```
➜  ipc gcc main.c
➜  ipc ./a.out
^C
➜  ipc
```

### 3. setbuf() 【取消】用户缓冲区

```c
#include <stdio.h>
int main()
{
  // 取消用户缓冲区
  setbuf(stdout, (void*)0);

  printf("Hello");
  while(1);
}
```

```
➜  ipc gcc main.c
➜  ipc ./a.out
Hello^C
➜  ipc
```

**取消** 用户缓冲区之后，写入 stdout 的数据 **不再被缓存**，直接写入文件。

### 4. `setbuf(FILE*, char buf[])` 文件指针指向 `一块内存`，而不再是文件

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define BUFFSIZE 50

int main()
{
  char buf[BUFFSIZE];
  FILE* p;

  // 1. 打开文件
  p = fopen("./txt", "wb+");

  // 2. 重新设置 FILE* 指向一块【内存块】(默认情况下 FILE* 指向某一个文件)
  setbuf(p, buf);

  // 3. 向 FILE* 写入数据
  // => 其实是向 FILE* 指向的【内存块】中写入数据
  // => 并【不直接】写入文件
  fwrite("hello\n", strlen("hello\n"), 1, p);
  fwrite("world\n", strlen("world\n")+1/*多1个0结束符*/, 1, p);

  // 4. 打印内存块中缓存数据
  printf("buf = %s\n", buf);

  // 5. 关闭文件时，才会触发缓冲区数据写入到磁盘文件
  fclose(p);
}
```

```
->  gcc main.c
->  ./a.out
buf = hello
world

->  cat txt
hello
world
->
```

### 5. setbuf() 设置文件读写时，使用自定义的内存缓存

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define BUFFSIZE 50

int main()
{
  int len;
  char cache[BUFFSIZE];
  char buf[50];
  FILE* p;

  // 1. 打开文件
  p = fopen("./txt", "rb+");
  printf("p = %p\n", p);

  // 2. 重新设置FILE*指向的内存块
  setbuf(p, cache);

  // 3. 将FILE*关联的文件数据，读取到自定义的内存缓存中
  for(;fgets(buf, BUFFSIZE, p);)
  {
    printf("buf = %s", buf);
    memset(buf, 0, BUFFSIZE);
  }

  // 4. 关闭文件时，才会触发缓冲区数据写入到磁盘文件
  fclose(p);
}
```

```
->  cat txt
hello
world
->  gcc main.c
->  ./a.out
p = 0x8e51008
buf = hello
buf = world
buf = ->
```



## 19、fmemopen() 与 open_memstream()

### 1. fmemopen()

```c
#include <stdio.h>

FILE*
fmemopen(
  void *buf,        // FILE* 指向的某一块内存块起始地址
  size_t size,      // 内存内存块的大小
  const char *mode  // 内存块的访问权限
);
```

- 1、自己预先申请一块内存块
- 2、作为 `FILE*` 指向的内存

其中参数 **mode** 的选项值![Snip20171210_4](Snip20171210_4.png)

### 2. open_wmemstream()

```c
FILE *
open_wmemstream(
  wchar_t **ptr, // 回传分配的内存块的起始地址
  size_t *sizeloc // 回传分配的内存块大小
);
```

- 直接由内核完成内存块的申请，而不需要开发者自己申请

```c
int main()
{
  char* mem = (void*)0;
  size_t size = 0;
  FILE* out = open_memstream(&mem, &size);
}
```

### 3. `FILE* p = fmemopen(buff[])`

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

int main()
{
  char buff1[] = "hello\n";
  char buff2[1024];
  
  // fmemopen()关联buff1[]
  FILE* p = fmemopen(buff1, 1024, "r"); 
    
  // 将fmemopen()关联buff1[]中数据，写入到buff2[]
  fread(buff2, 1, 6, p); 
    
  printf("%s", buff2);
    fclose(p);
}
```

```
->  gcc main.c
->  ./a.out
hello
->
```

### 4. `fscanf(fmemopen(buf[]))`

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int main()
{
  int x;
  char buff1[] = "uname=xiong pwd=38342";
  char buff2[20] = {0};
  char uname[10] = {0};
  char pwd[10] = {0};

  FILE* p = fmemopen(buff1, strlen(buff1), "r");

  for (;;) {
    //从FILE*指向的内存中，读取输入数据
    if (fscanf(p, "uname=%s pwd=%s", uname, pwd) <= 0)
      break;
    printf("uname = %s, pwd = %s\n", uname, pwd);
  }

  fclose(p);
}
```

```
->  gcc main.c
->  ./a.out
1, 2, 3, 4, 5,
->
```

代替了 **stdin** 标准输入中读取字符。

### 5. open_memstream() 由内核分配内存

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int main()
{
  int x;
  //char buff[] = "1 2 3 4 5"; 会崩溃
  char* buff = "1 2 3 4 5";
  FILE* in;
  FILE* out;
  char* mem = (void*)0;
  size_t size = 0;

  //1. fmemopen() 打开【读取】内存
  in = fmemopen(buff, strlen(buff), "r");

  //2. open_memstream() 打开【写入】内存
  out = open_memstream(&mem, &size);
  printf("in = %p, out = %p\n", in, out);
  printf("--------------------------\n");
  printf("mem = %s\n", mem);
  printf("mem.size = %d\n", size);
  printf("--------------------------\n");

  //3. 读取fmemopen()内存，写入到open_memstream()内存
  for (;;)
  {
    // 将in指向的内存中读取数据到变量x
    if (fscanf(in, "%d", &x) <= 0)
      break;

    // 将变量x的值写入到out指向的内存
    fprintf(out, "%d ", x);
  }

  //4. 一定要关闭文件，才能刷新缓冲区，数据才会写入到文件
  fclose(in);
  fclose(out);

  //5. 文件关闭刷新缓冲区后，才能读取到数据
  printf("mem = %s\n", mem);
  printf("mem.size = %d\n", size);

  //6. 释放掉开辟的内存
  free(mem);
}
```

```
->  gcc main.c
->  ./a.out
in = 0x8eb0028, out = 0x8eb00e8
--------------------------
mem = (null)
mem.size = 0
--------------------------
mem = 1 2 3 4 5
mem.size = 10
->
```



## 20、文件编码

### 1. ASCII码 

- 1）使用【0 到 127】表示所有的英文字母、符号
- 2）常见字符的ascii编码值
  - 空格"SPACE"是32(二进制00100000)
  - 大写字母A是65(二进制01000001)
- 3）计算机数据存储统一使用ascii编码

### 2. unicode

- 1）国际组织设计, 可以容纳全世界所有语言文字的编码方案
- 2）将世界上所有的符号都纳入其中，对每一个符号都给予一个独一无二的编码，那么乱码问题就会消失


- 3）问题1：但是只规定了符号的【二进制代码】，却没有规定这个二进制代码应该【如何存储】
  - 汉字"严"的unicode是十六进制数4E25, 
  - 转换成二进制数足足有15位（100111000100101）
  - 所以这个符号的表示至少需要2个字节.
  - 如果表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多的字节

- 4）问题2：如何才能区别unicode和ascii？
  - 一个中文汉字可能需要3个字节、4个字节...存储对应的二进制位
  - 如果所有的unicode字符都是要最大长度字节来存储，则造成空间的浪费
  - 但是不使用最大长度存储，又无法知道某个中文字符到底是2个字节、3个字节、4个字节...存储

所以unicode并没有得到推广。

### 3. utf-8

#### 1. UTF-8 编码规则

##### 1. 对于 `1字节` 编码规则

- 1）字节的第一位设为0
- 2）后面7位为这个符号的unicode码

因此对于【英语】字母, 【UTF-8】编码和【ASCII】码是【相同】的.

##### 2. 对于 `n(n>1)字节` 编码规则

- 1）第一个字节的【前n位】都设为【1】
- 2）第【n+1】位设为【0】
- 3）后面字节的【前两位】一律设为【10】
- 4）剩下的没有提及的二进制位，就是这个符号的unicode码的二进制位数值
- 5）UTF8编码默认使用【大端存储】，所以没有【字节序转换】的问题

|  Unicode符号范围 |  UTF-8编码方式  |
| n（符号的字节数） |  (十六进制)  | (二进制) |
|:----|:--------------------|:---------------------------------------------------|
| 1 | 0000 0000 - 0000 007F |0xxxxxxx|
| 2 | 0000 0080 - 0000 07FF |110xxxxx 10xxxxxx |
| 3 | 0000 0800 - 0000 FFFF |1110xxxx 10xxxxxx 10xxxxxx  |
| 4 | 0001 0000 - 0010 FFFF |11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |
| 5 | 0020 0000 - 03FF FFFF |111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx|
| 6 | 0400 0000 - 7FFF FFFF |1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx|

注意：使用的【大端存储】模式。（低位放高位）

### 4. 大端与小端存储

- 1）Unicode规范中定义，每一个文件的最前面的【2个字节】表示文件的大端还是小端存储
- 2）大端存储 => 0xFEFF
- 3）小端存储 => 0xFFFE

### 5. 打开文件乱码的原因

- 1）所有的文件都是以【A 编码】格式打开并写入数据的
- 2）所以要想打开一个文本文件, 就必须知道它的【编码】方式
- 3）如果【打开文件】时使用的编码与【文件本身】的编码【不一致】，则打开文件后看到的都是【乱码】
- 4）原因是各种不同的编码，【能够表示的字符范围】不一致，超出范围的字符则无法表示


